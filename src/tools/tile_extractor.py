#!/usr/bin/env python3
"""
tile_extractor.py

Extracts tile data from Game Boy ROMs and generates hash dictionaries
for the translation overlay system.

Usage:
    uv run python src/tools/tile_extractor.py <rom_file> [--output <output_dir>]

This tool:
1. Loads a GB/GBC ROM
2. Identifies font tiles (manual or heuristic)
3. Extracts tile bitmap data
4. Computes CRC-16 hashes for each tile
5. Generates .mif files for FPGA hash table initialization
"""

import argparse
import struct
from pathlib import Path
from typing import NamedTuple

import numpy as np
from PIL import Image


class TileData(NamedTuple):
    """Represents a single 8x8 tile"""
    index: int
    data: bytes  # 16 bytes for GB 2bpp format
    hash: int    # CRC-16 hash


def crc16_ccitt(data: bytes, init: int = 0xFFFF) -> int:
    """
    Compute CRC-16-CCITT hash (polynomial 0x1021).
    Same algorithm as implemented in tile_hash_generator.sv
    """
    crc = init
    for byte in data:
        crc ^= byte << 8
        for _ in range(8):
            if crc & 0x8000:
                crc = ((crc << 1) ^ 0x1021) & 0xFFFF
            else:
                crc = (crc << 1) & 0xFFFF
    return crc


def extract_tile(rom_data: bytes, tile_addr: int) -> bytes:
    """
    Extract a single 8x8 tile (16 bytes) from ROM.
    GB tiles are stored in 2bpp interleaved format.
    """
    return rom_data[tile_addr:tile_addr + 16]


def tile_to_image(tile_data: bytes) -> np.ndarray:
    """
    Convert GB 2bpp tile data to 8x8 grayscale image.
    """
    img = np.zeros((8, 8), dtype=np.uint8)

    for row in range(8):
        low_byte = tile_data[row * 2]
        high_byte = tile_data[row * 2 + 1]

        for col in range(8):
            bit_pos = 7 - col
            low_bit = (low_byte >> bit_pos) & 1
            high_bit = (high_byte >> bit_pos) & 1
            pixel = (high_bit << 1) | low_bit

            # Map 2bpp value to grayscale (0=white, 3=black)
            gray_map = [255, 170, 85, 0]
            img[row, col] = gray_map[pixel]

    return img


def find_font_tiles_heuristic(rom_data: bytes) -> list[int]:
    """
    Attempt to automatically find font tiles in a ROM.
    Looks for sequences of tiles that resemble text characters.

    Returns list of tile addresses that likely contain font data.
    """
    # Common font locations in Pokemon games
    # Pokemon Red/Green/Blue (JP): 0x8000 offset in VRAM, but stored in ROM...
    # This is game-specific and would need research per game

    # For now, return empty list - user should specify manually
    print("Automatic font detection not yet implemented.")
    print("Please specify tile range manually with --tile-start and --tile-count")
    return []


def extract_tiles_from_rom(
    rom_path: Path,
    tile_start: int,
    tile_count: int
) -> list[TileData]:
    """
    Extract tiles from ROM and compute hashes.
    """
    with open(rom_path, 'rb') as f:
        rom_data = f.read()

    tiles = []
    for i in range(tile_count):
        addr = tile_start + (i * 16)  # 16 bytes per tile
        if addr + 16 > len(rom_data):
            print(f"Warning: Tile {i} extends past ROM end")
            break

        data = extract_tile(rom_data, addr)
        tile_hash = crc16_ccitt(data)

        tiles.append(TileData(
            index=i,
            data=data,
            hash=tile_hash
        ))

    return tiles


def generate_mif_file(tiles: list[TileData], output_path: Path):
    """
    Generate Memory Initialization File for FPGA BRAM.
    Format compatible with Intel Quartus.
    """
    with open(output_path, 'w') as f:
        f.write("-- Tile Hash Dictionary\n")
        f.write("-- Generated by tile_extractor.py\n")
        f.write(f"-- {len(tiles)} entries\n\n")

        f.write("WIDTH = 40;\n")  # valid(1) + hash(16) + char_code(8) + trans_ptr(15)
        f.write(f"DEPTH = {len(tiles)};\n")
        f.write("ADDRESS_RADIX = HEX;\n")
        f.write("DATA_RADIX = HEX;\n\n")
        f.write("CONTENT BEGIN\n")

        for tile in tiles:
            # Entry format: {valid, hash, char_code, translation_ptr}
            # For now, char_code = tile index, translation_ptr = 0
            valid = 1
            entry = (valid << 39) | (tile.hash << 23) | (tile.index << 15) | 0

            f.write(f"  {tile.index:04X} : {entry:010X};\n")

        f.write("END;\n")

    print(f"Generated MIF file: {output_path}")


def generate_hex_file(tiles: list[TileData], output_path: Path):
    """
    Generate simple hex file with tile hashes.
    """
    with open(output_path, 'w') as f:
        for tile in tiles:
            f.write(f"{tile.hash:04X}\n")

    print(f"Generated hex file: {output_path}")


def save_tile_images(tiles: list[TileData], output_dir: Path):
    """
    Save each tile as a PNG image for visual inspection.
    """
    output_dir.mkdir(parents=True, exist_ok=True)

    for tile in tiles:
        img_data = tile_to_image(tile.data)
        img = Image.fromarray(img_data, mode='L')

        # Scale up for visibility (8x8 -> 64x64)
        img = img.resize((64, 64), Image.Resampling.NEAREST)

        filename = output_dir / f"tile_{tile.index:03d}_hash_{tile.hash:04X}.png"
        img.save(filename)

    print(f"Saved {len(tiles)} tile images to {output_dir}")


def create_tileset_image(tiles: list[TileData], output_path: Path, cols: int = 16):
    """
    Create a tileset image showing all tiles in a grid.
    """
    rows = (len(tiles) + cols - 1) // cols
    tileset = np.ones((rows * 8, cols * 8), dtype=np.uint8) * 255

    for i, tile in enumerate(tiles):
        row = i // cols
        col = i % cols
        tile_img = tile_to_image(tile.data)
        tileset[row*8:(row+1)*8, col*8:(col+1)*8] = tile_img

    img = Image.fromarray(tileset, mode='L')
    img = img.resize((cols * 64, rows * 64), Image.Resampling.NEAREST)
    img.save(output_path)

    print(f"Saved tileset image: {output_path}")


def main():
    parser = argparse.ArgumentParser(
        description="Extract tiles from GB ROMs and generate hash dictionaries"
    )
    parser.add_argument("rom", type=Path, help="Path to GB/GBC ROM file")
    parser.add_argument("--output", "-o", type=Path, default=Path("output"),
                        help="Output directory")
    parser.add_argument("--tile-start", "-s", type=lambda x: int(x, 0),
                        required=True,
                        help="Start address of tiles in ROM (hex or decimal)")
    parser.add_argument("--tile-count", "-n", type=int, required=True,
                        help="Number of tiles to extract")
    parser.add_argument("--save-images", action="store_true",
                        help="Save individual tile images")
    parser.add_argument("--game-name", "-g", type=str, default="unknown",
                        help="Game name for output files")

    args = parser.parse_args()

    if not args.rom.exists():
        print(f"Error: ROM file not found: {args.rom}")
        return 1

    print(f"Extracting tiles from: {args.rom}")
    print(f"Start address: 0x{args.tile_start:X}")
    print(f"Tile count: {args.tile_count}")

    # Extract tiles
    tiles = extract_tiles_from_rom(args.rom, args.tile_start, args.tile_count)
    print(f"Extracted {len(tiles)} tiles")

    # Create output directory
    game_dir = args.output / args.game_name
    game_dir.mkdir(parents=True, exist_ok=True)

    # Generate outputs
    generate_mif_file(tiles, game_dir / "tile_hashes.mif")
    generate_hex_file(tiles, game_dir / "tile_hashes.hex")
    create_tileset_image(tiles, game_dir / "tileset.png")

    if args.save_images:
        save_tile_images(tiles, game_dir / "tiles")

    # Print hash summary
    print("\nTile Hash Summary:")
    print("-" * 40)
    for tile in tiles[:10]:  # First 10 tiles
        print(f"Tile {tile.index:3d}: hash=0x{tile.hash:04X}")
    if len(tiles) > 10:
        print(f"... and {len(tiles) - 10} more tiles")

    return 0


if __name__ == "__main__":
    exit(main())
